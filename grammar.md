
------------------------------------------------------


Below is a **clean, complete, *non–left-recursive*, pure CFG grammar** for your MiniC-like language based ONLY on the features you listed.

It contains:

### ✔ No left recursion

### ✔ No EBNF (`+`, `*`, `?`)

### ✔ Only terminals + nonterminals

### ✔ All language features you described

### ✔ Suitable for a recursive-descent parser

---

# ✅ **MiniC Grammar (Non–Left-Recursive, Pure CFG)**

**Start Symbol**

```
Program → FunctionList
```

```
FunctionList → Function FunctionList
             | Function
```

---

# 1. Functions

```
Function → func Type Identifier "(" ParamListOpt ")" Block
```

### **Parameters**

```
ParamListOpt → ParamList
             | ε
```

```
ParamList → Param ParamListTail
```

```
ParamListTail → "," Param ParamListTail
               | ε
```

```
Param → Type Identifier
```

---

# 2. Types

```
Type → int
     | float
     | bool
```

---

# 3. Blocks & Statements

```
Block → "{" StmtList "}"
```

```
StmtList → Stmt StmtList
         | ε
```

```
Stmt → VarDecl
     | AssignmentStmt
     | IfStmt
     | WhileStmt
     | ForStmt
     | ReturnStmt
     | PrintStmt
     | ReadStmt
     | FuncCallStmt
     | ExprStmt
```

---

# 4. Declarations & Assignments

### Variable declaration

```
VarDecl → Type Identifier VarInitOpt ";"
```

```
VarInitOpt → "=" Expr
            | ε
```

### Assignment

```
AssignmentStmt → Identifier "=" Expr ";"
```

### Function call as a statement

```
FuncCallStmt → Identifier "(" ArgListOpt ")" ";"
```

---

# 5. Input/Output

```
PrintStmt → print "(" Expr ")" ";"
ReadStmt  → read "(" Identifier ")" ";"
```

---

# 6. Control Structures

### If–Else

```
IfStmt → if "(" Expr ")" Block ElseOpt
```

```
ElseOpt → else Block
        | ε
```

### While

```
WhileStmt → while "(" Expr ")" Block
```

### For Loop

```
ForStmt → for "(" ForInit ";" ForCond ";" ForStep ")" Block
```

```
ForInit → VarDeclNoSemicolon
        | AssignmentExpr
        | ε
```

```
VarDeclNoSemicolon → Type Identifier VarInitOpt
```

```
ForCond → Expr
        | ε
```

```
ForStep → AssignmentExpr
        | ε
```

---

# 7. Expressions (with correct precedence & NO left recursion)

## Entry rule

```
Expr → LogicalOr
```

---

## Logical OR

```
LogicalOr → LogicalAnd LogicalOrTail
```

```
LogicalOrTail → "||" LogicalAnd LogicalOrTail
               | ε
```

---

## Logical AND

```
LogicalAnd → Equality EqualityTail
```

```
EqualityTail → "&&" Equality EqualityTail
              | ε
```

---

## Equality

```
Equality → Relational EqualityOpTail
```

```
EqualityOpTail → EqualityOp Relational EqualityOpTail
                | ε
```

```
EqualityOp → "==" | "!="
```

---

## Relational

```
Relational → Additive RelOpTail
```

```
RelOpTail → RelOp Additive RelOpTail
           | ε
```

```
RelOp → "<" | ">" | "<=" | ">="
```

---

## Additive

```
Additive → Multiplicative AddOpTail
```

```
AddOpTail → AddOp Multiplicative AddOpTail
           | ε
```

```
AddOp → "+" | "-"
```

---

## Multiplicative

```
Multiplicative → Unary MulOpTail
```

```
MulOpTail → MulOp Unary MulOpTail
           | ε
```

```
MulOp → "*" | "/" | "%"
```

---

## Unary

```
Unary → UnaryOp Unary
      | Primary
```

```
UnaryOp → "-" | "!" 
```

---

## Primary

```
Primary → Integer
        | Float
        | Boolean
        | Identifier
        | FuncCallExpr
        | "(" Expr ")"
```

---

## Function call (expression context)

```
FuncCallExpr → Identifier "(" ArgListOpt ")"
```

---

## Arguments

```
ArgListOpt → ArgList
            | ε
```

```
ArgList → Expr ArgListTail
```

```
ArgListTail → "," Expr ArgListTail
             | ε
```

---

# 8. Expression statement

```
ExprStmt → Expr ";"
```

---

# 9. Assignment expression (for loops)

```
AssignmentExpr → Identifier "=" Expr
```

---

# 10. Lexical Tokens

(Not formal CFG, but listed for completeness)

```
Integer    → DIGIT+
Float      → DIGIT+ "." DIGIT+
Boolean    → true | false
Identifier → LETTER (LETTER | DIGIT | "_")*
```


---------------------------------------------------------------

GENERATED BY COPILOT

----------------------------------------------------------------

MiniC — language grammar (EBNF)

Start symbol
-----------
Program → FunctionList


Top-level rule
--------------
FunctionDecl ::= 'func' Type Identifier '(' ParameterList? ')' Block

Types & Keywords
-----------------
Type ::= 'int' | 'float' | 'bool'
Keyword tokens include: func, return, if, else, for, while, print, read, true, false

Parameters
----------
ParameterList ::= Parameter (',' Parameter)*
Parameter ::= Type Identifier

Blocks & Statements
-------------------
Block ::= '{' Statement* '}'

Statement ::=
    ReturnStmt
  | PrintStmt
  | ReadStmt
  | IfStmt
  | WhileStmt
  | ForStmt
  | VarDecl
  | AssignmentStmt
  | FuncCallStmt
  | ExpressionStmt

ReturnStmt ::= 'return' Expression ';'
PrintStmt  ::= 'print' '(' Expression ')' ';'
ReadStmt   ::= 'read' '(' Identifier ')' ';'

IfStmt ::= 'if' '(' Expression ')' Block ('else' Block)?
WhileStmt ::= 'while' '(' Expression ')' Block

ForStmt ::= 'for' '(' ForInit ';' ForCond ';' ForStep ')' Block
ForInit ::= /* empty */ | VarDecl | AssignmentExpr
ForCond ::= /* empty */ | Expression
ForStep ::= /* empty */ | AssignmentExpr

VarDecl ::= Type Identifier ('=' Expression)? ';'
AssignmentStmt ::= Identifier '=' Expression ';'
FuncCallStmt ::= Identifier '(' ArgList? ')' ';'
ExpressionStmt ::= Expression ';'

Expressions (precedence, lowest → highest)
-----------------------------------------
Expression ::= LogicalOr
LogicalOr  ::= LogicalAnd ( '||' LogicalAnd )*
LogicalAnd ::= Equality ( '&&' Equality )*
Equality   ::= Relational (('==' | '!=') Relational)*
Relational ::= Additive (('<' | '>' | '<=' | '>=') Additive)*
Additive   ::= Multiplicative (('+' | '-') Multiplicative)*
Multiplicative ::= Unary (('*' | '/' | '%') Unary)*
Unary      ::= ('-' | '!' | '~') Unary | Primary
Primary    ::= Integer | Float | Boolean | Identifier | FuncCallExpr | '(' Expression ')'
FuncCallExpr ::= Identifier '(' ArgList? ')'
ArgList ::= Expression (',' Expression)*

Literals & tokens
-----------------
Integer  ::= [0-9]+
Float    ::= [0-9]+\.[0-9]+  (single decimal point allowed)
Boolean  ::= 'true' | 'false'
Identifier ::= [A-Za-z_][A-Za-z0-9_]*

Notes and parser behavior
-------------------------
- Every function declaration must begin with the 'func' keyword (including the entry point `main`).
- This grammar is intentionally simple and geared for a simple recursive-descent parser.
- The implementation in `lookaheadparser.py` follows recursive-descent style: each nonterminal is implemented by a Python function (e.g., parse_expression(), parse_block(), parse_statement(), parse_function_declaration()).  The parser consumes tokens via nextToken()/lookahead() and each nonterminal function delegates to other nonterminals recursively.
- The expression parser implements operator precedence using a series of functions from parse_logical_or → parse_primary.
- The lexer (lexer.py) emits tokens such as ('Type','int',line), ('Keyword','return',line), ('Operator','+',line), ('Assign','=',line), etc.

Example program (valid):

func int add(int a, int b) {
    return a + b;
}

func int main() {
    int x = 5;
    int y = add(2, 3);
    print(x);
    print(y);
    return 0;
}


Implementation pointers
-----------------------
- If you add new statements or expressions, add a corresponding nonterminal parsing function in `lookaheadparser.py` and update the lexer if you need new tokens.
- Prefer returning AST node objects (see `ASTNodes.py`) from parsing functions so later stages (type checking / codegen) can operate on structured data.
